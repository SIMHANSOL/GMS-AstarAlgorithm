<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>Spr_Player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CREATE.

grid_size_x = 32; // 그리드 X 사이즈.
grid_size_y = 32; // 그리드 Y 사이즈.
grid_width = ceil(room_width / grid_size_x) + 1; // 박스 가로 크기.
grid_height = ceil(room_height / grid_size_y) + 1; // 박스 세로 크기.
grid_block_add = true; // 그리드 충돌 검사. (충돌 검사는 true)

for(var _i = 0; _i &lt; grid_width; _i++)
{
    for (var _j = 0; _j &lt; grid_height; _j++)
    {
        grid_table[_i, _j] = true; // 통과할 수 있는지 확인. (가능하면 true)
    }
}

path = -1;

debug_f = ds_priority_create();
debug_f_list = ds_list_create(); // 시각화.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// STEP.
if (grid_block_add == true)
{
    with(Obj_Wall)
    {
        var _x = x div other.grid_size_x;
        var _y = y div other.grid_size_y;
        other.grid_table[_x, _y] = false;
    }
    grid_block_add = false;
}

if (mouse_check_button_pressed(mb_left) == true)
{
    ds_priority_clear(debug_f);
    ds_list_clear(debug_f_list);
    
    var _size_x = (grid_size_x / 2);
    var _size_y = (grid_size_y / 2);
    var _x = (x + _size_x) div grid_size_x;
    var _y = (y + _size_y) div grid_size_y;
    var _mx = (mouse_x + _size_x) div grid_size_x;
    var _my = (mouse_y + _size_y) div grid_size_y;
    
    path = a_path(_x, _y, _mx, _my);
    if (path != -1)
    {
        path_start(path, 2, 0, true);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DRAW.

// 그리드.
var _size_x = (grid_size_x / 2);
var _size_y = (grid_size_y / 2);

for(var _i = 0; _i &lt; grid_width; _i++)
{
    for (var _j = 0; _j &lt; grid_height; _j++)
    {
        // 그리드 숫자 표시.
        draw_text((_i * 32) - 16, (_j * 32) - 16, string(_i) + "#" + string(_j));
    }
}

// 시각화 표시.
while(ds_priority_empty(debug_f) == false)
{
    ds_list_add(debug_f_list, ds_priority_delete_min(debug_f));
}

draw_set_colour(c_yellow);
for(var _i = 0; _i &lt; ds_list_size(debug_f_list); _i++)
{
    var _key = ds_list_find_value(debug_f_list, _i);
    var _x = get_key_x(_key) * grid_size_x;
    var _y = get_key_y(_key) * grid_size_y;

    draw_rectangle(_x - (grid_size_x / 2), _y - (grid_size_y / 2), _x + (grid_size_x / 2), _y + (grid_size_y / 2), 0);
}

// 자신 표시.
draw_self();

// 패스 표시.
draw_set_colour(c_black);
for(var _i = 0; _i &lt; path_get_number(path) - 1; _i++)
{
    var _px = path_get_point_x(path, _i);
    var _py = path_get_point_y(path, _i);
    var _pxx = path_get_point_x(path, _i + 1);
    var _pyy = path_get_point_y(path, _i + 1);
    draw_line(_px, _py, _pxx, _pyy);
}

draw_set_colour(c_green);
draw_circle(path_get_point_x(path, 0), path_get_point_y(path, 0), 8, 0);
draw_set_colour(c_red);
draw_circle(path_get_point_x(path, path_get_number(path) - 1), path_get_point_y(path, path_get_number(path) - 1), 8, 0);

// 격자선 표시.
draw_set_colour(c_black);
for(var i = 0; i &lt; grid_width; i++)
{
    draw_line((grid_size_x * i) + _size_x, 0, (grid_size_x * i) + _size_x, room_height);
}
for(var j = 0; j &lt; grid_height; j++)
{
    draw_line(0, (grid_size_y * j) + _size_y, room_width, (grid_size_y * j) + _size_y);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
